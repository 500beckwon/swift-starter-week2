소스코드가 보기에 매우 복잡하므로 매우 상세히 설명드리겠습니다. 하하하하

Method 파일에서는 일단 로또번호 생성 함수 createLotto()를 만들었습니다.
11 ~ 12 Int형 함수 x와 Int를 담을 배열인 randomVars를 만들어주었습니다.
13 ~ 그 후에 Int.random을 통해 1~45 사이의 숫자를 랜덤으로 뽑아서 randomVars.append(x)를 통해
     배열에 넣었고 randomVars.count가 6이 될 때까지 반복해줍니다. 이 때에 만약 randomVars에 겹치는
     숫자(x)가 있다면 아무런 소스코드도 실행하지 않았고 그 외의 경우에만 append를 실행하였습니다.

main 파일에서는 
3 ~ 5 제가 뽑은 로또숫자 myLottoNumbers, 랜덤 숫자를 넣어놓은 lottoNumbers, myLottoNumbers와 lottoNumbers에서 겹치는 숫자를 넣어줄 correctNumbers를 선언하였습니다.

7 ~ 10 1부터 myLottoNumbers의 크기만큼 반복문을 돌려주며 lottoNumbers가 myLottoNumbers의 숫자를 가지고 있다면 correctNumbers에 숫자를 넣어줍니다. 이 때에 반복문은 1부터 시작하므로 myLottoNumbers의 괄호안에는 i가 아닌 i-1을 넣습니다.

13 ~ 만약 correctNumbers의 갯수가 0개가 아니라면 "축하합니다! ~"를 출력해주고 그 외에는 "아쉽지만 ~"을 출력합니다.

15  반복문을 통해 correctNumbers에서 숫자를 하나씩 꺼내며 print 해줍니다. 이 때에
17 꺼낸 숫자가 correctNumbers의 마지막 숫자라면 띄어쓰기만 해줍니다.
20 첫 번째 숫자가 아니며 마지막 숫자도 아니라면 콤마(,)를 넣어줍니다.
23 첫 번째 숫자라면 띄어쓰기만 해줍니다.

코드를 보시면 아시겠지만 제가 한 방법은 일단 숫자를 출력하기 전에 문자를 쭉 써놓고 숫자를 출력할 때마다 그
숫자가 첫 번째 숫자인지, 중간쯤에 있는 숫자인지, 마지막 숫자인지를 판별하여 그 다음에 띄어쓰기(" ")가 올
것인지 아니면 콤마(,)가 올 것인지를 판단하여 출력하는 코드입니다.

그리고 기존의 흐름도하고 다른 점이 두 가지가 있습니다.
1. 원래는 함수를 통해 배열을 받고 insert를 한 후에 return하려고 했으나 배열을 받지 않고 그냥 배열을 생성하여 return 하는 방법으로 바꿨다.
2. Set타입으로 하려고 했으나 Array 방법으로 바꿨다.

이유는 다음과 같습니다.
1. 함수는 값을 반환하거나 출력을 하는 것이지 참조(conference)를 할 수 없다. 말이 조금 이상한데 정확히 이야기하면 변수에 있는 값을 변환하기 위해서는 보통 var x = 1, x = 2 이런 식으로 값을 변환할 수 있지만 함수에 값을 넘겨주게 된다면 메모리에 접근하는 방식이 달라져서 우리가 기존에 생각하던 방식으로는 값을 변환할 수 없다. 그래서 C언어에서는 포인터라는 방식으로 메모리에 접근하여 값을 바꾸었다.
    -> 말이 조금 이상한 것 같은데 저는 이러한 식으로 대충 이해하고 있습니다. ㅎㅎ;

2. 이거는 딱히 이유가 없습니다. 원래는 Set 타입으로 할까 하였으나 예거님이 Array로 해도 충분히 할 수 있다고 하셔서 뭐.....그냥 해볼까..? 해서 해봤습니다 ㅋㅋㅋ
